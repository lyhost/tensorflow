// Code generated by protoc-gen-go. DO NOT EDIT.
// source: tensorflow/contrib/tensor_forest/proto/tensor_forest_params.proto

package tensor_forest

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	decision_trees "github.com/tensorflow/tensorflow/tensorflow/go/core/contrib/decision_trees"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// Leaf models specify what is returned at inference time, and how it is
// stored in the decision_trees.Leaf protos.
type LeafModelType int32

const (
	LeafModelType_MODEL_DENSE_CLASSIFICATION           LeafModelType = 0
	LeafModelType_MODEL_SPARSE_CLASSIFICATION          LeafModelType = 1
	LeafModelType_MODEL_REGRESSION                     LeafModelType = 2
	LeafModelType_MODEL_SPARSE_OR_DENSE_CLASSIFICATION LeafModelType = 3
)

var LeafModelType_name = map[int32]string{
	0: "MODEL_DENSE_CLASSIFICATION",
	1: "MODEL_SPARSE_CLASSIFICATION",
	2: "MODEL_REGRESSION",
	3: "MODEL_SPARSE_OR_DENSE_CLASSIFICATION",
}

var LeafModelType_value = map[string]int32{
	"MODEL_DENSE_CLASSIFICATION":           0,
	"MODEL_SPARSE_CLASSIFICATION":          1,
	"MODEL_REGRESSION":                     2,
	"MODEL_SPARSE_OR_DENSE_CLASSIFICATION": 3,
}

func (x LeafModelType) String() string {
	return proto.EnumName(LeafModelType_name, int32(x))
}

func (LeafModelType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a700a4f06122ab7a, []int{0}
}

// Stats models generally specify information that is collected which is
// necessary to choose a split at a node. Specifically, they operate on
// a SplitCandidate::LeafStat proto.
type StatsModelType int32

const (
	StatsModelType_STATS_DENSE_GINI               StatsModelType = 0
	StatsModelType_STATS_SPARSE_GINI              StatsModelType = 1
	StatsModelType_STATS_LEAST_SQUARES_REGRESSION StatsModelType = 2
	// STATS_SPARSE_THEN_DENSE_GINI is deprecated and no longer supported.
	StatsModelType_STATS_SPARSE_THEN_DENSE_GINI StatsModelType = 3
	StatsModelType_STATS_FIXED_SIZE_SPARSE_GINI StatsModelType = 4
)

var StatsModelType_name = map[int32]string{
	0: "STATS_DENSE_GINI",
	1: "STATS_SPARSE_GINI",
	2: "STATS_LEAST_SQUARES_REGRESSION",
	3: "STATS_SPARSE_THEN_DENSE_GINI",
	4: "STATS_FIXED_SIZE_SPARSE_GINI",
}

var StatsModelType_value = map[string]int32{
	"STATS_DENSE_GINI":               0,
	"STATS_SPARSE_GINI":              1,
	"STATS_LEAST_SQUARES_REGRESSION": 2,
	"STATS_SPARSE_THEN_DENSE_GINI":   3,
	"STATS_FIXED_SIZE_SPARSE_GINI":   4,
}

func (x StatsModelType) String() string {
	return proto.EnumName(StatsModelType_name, int32(x))
}

func (StatsModelType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a700a4f06122ab7a, []int{1}
}

// Allows selection of operations on the collection of split candidates.
// Basic infers right split stats from the leaf stats and each candidate's
// left stats.
type SplitCollectionType int32

const (
	SplitCollectionType_COLLECTION_BASIC        SplitCollectionType = 0
	SplitCollectionType_GRAPH_RUNNER_COLLECTION SplitCollectionType = 1
)

var SplitCollectionType_name = map[int32]string{
	0: "COLLECTION_BASIC",
	1: "GRAPH_RUNNER_COLLECTION",
}

var SplitCollectionType_value = map[string]int32{
	"COLLECTION_BASIC":        0,
	"GRAPH_RUNNER_COLLECTION": 1,
}

func (x SplitCollectionType) String() string {
	return proto.EnumName(SplitCollectionType_name, int32(x))
}

func (SplitCollectionType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a700a4f06122ab7a, []int{2}
}

// Pruning strategies define how candidates are pruned over time.
// SPLIT_PRUNE_HALF prunes the worst half of splits every prune_ever_samples,
// etc.  Note that prune_every_samples plays against the depth-dependent
// split_after_samples, so they should be set together.
type SplitPruningStrategyType int32

const (
	SplitPruningStrategyType_SPLIT_PRUNE_NONE       SplitPruningStrategyType = 0
	SplitPruningStrategyType_SPLIT_PRUNE_HALF       SplitPruningStrategyType = 1
	SplitPruningStrategyType_SPLIT_PRUNE_QUARTER    SplitPruningStrategyType = 2
	SplitPruningStrategyType_SPLIT_PRUNE_10_PERCENT SplitPruningStrategyType = 3
	// SPLIT_PRUNE_HOEFFDING prunes splits whose Gini impurity is worst than
	// the best split's by more than the Hoeffding bound.
	SplitPruningStrategyType_SPLIT_PRUNE_HOEFFDING SplitPruningStrategyType = 4
)

var SplitPruningStrategyType_name = map[int32]string{
	0: "SPLIT_PRUNE_NONE",
	1: "SPLIT_PRUNE_HALF",
	2: "SPLIT_PRUNE_QUARTER",
	3: "SPLIT_PRUNE_10_PERCENT",
	4: "SPLIT_PRUNE_HOEFFDING",
}

var SplitPruningStrategyType_value = map[string]int32{
	"SPLIT_PRUNE_NONE":       0,
	"SPLIT_PRUNE_HALF":       1,
	"SPLIT_PRUNE_QUARTER":    2,
	"SPLIT_PRUNE_10_PERCENT": 3,
	"SPLIT_PRUNE_HOEFFDING":  4,
}

func (x SplitPruningStrategyType) String() string {
	return proto.EnumName(SplitPruningStrategyType_name, int32(x))
}

func (SplitPruningStrategyType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a700a4f06122ab7a, []int{3}
}

// Finish strategies define when slots are considered finished.
// Basic requires at least split_after_samples, and doesn't allow slots to
// finish until the leaf has received more than one class. Hoeffding splits
// early after min_split_samples if one split is dominating the rest according
// to hoeffding bounds. Bootstrap does the same but compares gini's calculated
// with sampled smoothed counts.
type SplitFinishStrategyType int32

const (
	SplitFinishStrategyType_SPLIT_FINISH_BASIC              SplitFinishStrategyType = 0
	SplitFinishStrategyType_SPLIT_FINISH_DOMINATE_HOEFFDING SplitFinishStrategyType = 2
	SplitFinishStrategyType_SPLIT_FINISH_DOMINATE_BOOTSTRAP SplitFinishStrategyType = 3
)

var SplitFinishStrategyType_name = map[int32]string{
	0: "SPLIT_FINISH_BASIC",
	2: "SPLIT_FINISH_DOMINATE_HOEFFDING",
	3: "SPLIT_FINISH_DOMINATE_BOOTSTRAP",
}

var SplitFinishStrategyType_value = map[string]int32{
	"SPLIT_FINISH_BASIC":              0,
	"SPLIT_FINISH_DOMINATE_HOEFFDING": 2,
	"SPLIT_FINISH_DOMINATE_BOOTSTRAP": 3,
}

func (x SplitFinishStrategyType) String() string {
	return proto.EnumName(SplitFinishStrategyType_name, int32(x))
}

func (SplitFinishStrategyType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a700a4f06122ab7a, []int{4}
}

type SplitPruningConfig struct {
	PruneEverySamples    *DepthDependentParam     `protobuf:"bytes,1,opt,name=prune_every_samples,json=pruneEverySamples,proto3" json:"prune_every_samples,omitempty"`
	Type                 SplitPruningStrategyType `protobuf:"varint,2,opt,name=type,proto3,enum=tensorflow.tensorforest.SplitPruningStrategyType" json:"type,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *SplitPruningConfig) Reset()         { *m = SplitPruningConfig{} }
func (m *SplitPruningConfig) String() string { return proto.CompactTextString(m) }
func (*SplitPruningConfig) ProtoMessage()    {}
func (*SplitPruningConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_a700a4f06122ab7a, []int{0}
}

func (m *SplitPruningConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SplitPruningConfig.Unmarshal(m, b)
}
func (m *SplitPruningConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SplitPruningConfig.Marshal(b, m, deterministic)
}
func (m *SplitPruningConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SplitPruningConfig.Merge(m, src)
}
func (m *SplitPruningConfig) XXX_Size() int {
	return xxx_messageInfo_SplitPruningConfig.Size(m)
}
func (m *SplitPruningConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_SplitPruningConfig.DiscardUnknown(m)
}

var xxx_messageInfo_SplitPruningConfig proto.InternalMessageInfo

func (m *SplitPruningConfig) GetPruneEverySamples() *DepthDependentParam {
	if m != nil {
		return m.PruneEverySamples
	}
	return nil
}

func (m *SplitPruningConfig) GetType() SplitPruningStrategyType {
	if m != nil {
		return m.Type
	}
	return SplitPruningStrategyType_SPLIT_PRUNE_NONE
}

type SplitFinishConfig struct {
	// Configure how often we check for finish, because some finish methods
	// are expensive to perform.
	CheckEverySteps      *DepthDependentParam    `protobuf:"bytes,1,opt,name=check_every_steps,json=checkEverySteps,proto3" json:"check_every_steps,omitempty"`
	Type                 SplitFinishStrategyType `protobuf:"varint,2,opt,name=type,proto3,enum=tensorflow.tensorforest.SplitFinishStrategyType" json:"type,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *SplitFinishConfig) Reset()         { *m = SplitFinishConfig{} }
func (m *SplitFinishConfig) String() string { return proto.CompactTextString(m) }
func (*SplitFinishConfig) ProtoMessage()    {}
func (*SplitFinishConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_a700a4f06122ab7a, []int{1}
}

func (m *SplitFinishConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SplitFinishConfig.Unmarshal(m, b)
}
func (m *SplitFinishConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SplitFinishConfig.Marshal(b, m, deterministic)
}
func (m *SplitFinishConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SplitFinishConfig.Merge(m, src)
}
func (m *SplitFinishConfig) XXX_Size() int {
	return xxx_messageInfo_SplitFinishConfig.Size(m)
}
func (m *SplitFinishConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_SplitFinishConfig.DiscardUnknown(m)
}

var xxx_messageInfo_SplitFinishConfig proto.InternalMessageInfo

func (m *SplitFinishConfig) GetCheckEverySteps() *DepthDependentParam {
	if m != nil {
		return m.CheckEverySteps
	}
	return nil
}

func (m *SplitFinishConfig) GetType() SplitFinishStrategyType {
	if m != nil {
		return m.Type
	}
	return SplitFinishStrategyType_SPLIT_FINISH_BASIC
}

// A parameter that changes linearly with depth, with upper and lower bounds.
type LinearParam struct {
	Slope                float32  `protobuf:"fixed32,1,opt,name=slope,proto3" json:"slope,omitempty"`
	YIntercept           float32  `protobuf:"fixed32,2,opt,name=y_intercept,json=yIntercept,proto3" json:"y_intercept,omitempty"`
	MinVal               float32  `protobuf:"fixed32,3,opt,name=min_val,json=minVal,proto3" json:"min_val,omitempty"`
	MaxVal               float32  `protobuf:"fixed32,4,opt,name=max_val,json=maxVal,proto3" json:"max_val,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LinearParam) Reset()         { *m = LinearParam{} }
func (m *LinearParam) String() string { return proto.CompactTextString(m) }
func (*LinearParam) ProtoMessage()    {}
func (*LinearParam) Descriptor() ([]byte, []int) {
	return fileDescriptor_a700a4f06122ab7a, []int{2}
}

func (m *LinearParam) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_LinearParam.Unmarshal(m, b)
}
func (m *LinearParam) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_LinearParam.Marshal(b, m, deterministic)
}
func (m *LinearParam) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LinearParam.Merge(m, src)
}
func (m *LinearParam) XXX_Size() int {
	return xxx_messageInfo_LinearParam.Size(m)
}
func (m *LinearParam) XXX_DiscardUnknown() {
	xxx_messageInfo_LinearParam.DiscardUnknown(m)
}

var xxx_messageInfo_LinearParam proto.InternalMessageInfo

func (m *LinearParam) GetSlope() float32 {
	if m != nil {
		return m.Slope
	}
	return 0
}

func (m *LinearParam) GetYIntercept() float32 {
	if m != nil {
		return m.YIntercept
	}
	return 0
}

func (m *LinearParam) GetMinVal() float32 {
	if m != nil {
		return m.MinVal
	}
	return 0
}

func (m *LinearParam) GetMaxVal() float32 {
	if m != nil {
		return m.MaxVal
	}
	return 0
}

// A parameter that changes expoentially with the form
//     f = c + mb^(k*d)
// where:
//  c: constant bias
//  b: base
//  m: multiplier
//  k: depth multiplier
//  d: depth
type ExponentialParam struct {
	Bias                 float32  `protobuf:"fixed32,1,opt,name=bias,proto3" json:"bias,omitempty"`
	Base                 float32  `protobuf:"fixed32,2,opt,name=base,proto3" json:"base,omitempty"`
	Multiplier           float32  `protobuf:"fixed32,3,opt,name=multiplier,proto3" json:"multiplier,omitempty"`
	DepthMultiplier      float32  `protobuf:"fixed32,4,opt,name=depth_multiplier,json=depthMultiplier,proto3" json:"depth_multiplier,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ExponentialParam) Reset()         { *m = ExponentialParam{} }
func (m *ExponentialParam) String() string { return proto.CompactTextString(m) }
func (*ExponentialParam) ProtoMessage()    {}
func (*ExponentialParam) Descriptor() ([]byte, []int) {
	return fileDescriptor_a700a4f06122ab7a, []int{3}
}

func (m *ExponentialParam) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ExponentialParam.Unmarshal(m, b)
}
func (m *ExponentialParam) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ExponentialParam.Marshal(b, m, deterministic)
}
func (m *ExponentialParam) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExponentialParam.Merge(m, src)
}
func (m *ExponentialParam) XXX_Size() int {
	return xxx_messageInfo_ExponentialParam.Size(m)
}
func (m *ExponentialParam) XXX_DiscardUnknown() {
	xxx_messageInfo_ExponentialParam.DiscardUnknown(m)
}

var xxx_messageInfo_ExponentialParam proto.InternalMessageInfo

func (m *ExponentialParam) GetBias() float32 {
	if m != nil {
		return m.Bias
	}
	return 0
}

func (m *ExponentialParam) GetBase() float32 {
	if m != nil {
		return m.Base
	}
	return 0
}

func (m *ExponentialParam) GetMultiplier() float32 {
	if m != nil {
		return m.Multiplier
	}
	return 0
}

func (m *ExponentialParam) GetDepthMultiplier() float32 {
	if m != nil {
		return m.DepthMultiplier
	}
	return 0
}

// A parameter that is 'off' until depth >= a threshold, then is 'on'.
type ThresholdParam struct {
	OnValue              float32  `protobuf:"fixed32,1,opt,name=on_value,json=onValue,proto3" json:"on_value,omitempty"`
	OffValue             float32  `protobuf:"fixed32,2,opt,name=off_value,json=offValue,proto3" json:"off_value,omitempty"`
	Threshold            float32  `protobuf:"fixed32,3,opt,name=threshold,proto3" json:"threshold,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ThresholdParam) Reset()         { *m = ThresholdParam{} }
func (m *ThresholdParam) String() string { return proto.CompactTextString(m) }
func (*ThresholdParam) ProtoMessage()    {}
func (*ThresholdParam) Descriptor() ([]byte, []int) {
	return fileDescriptor_a700a4f06122ab7a, []int{4}
}

func (m *ThresholdParam) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ThresholdParam.Unmarshal(m, b)
}
func (m *ThresholdParam) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ThresholdParam.Marshal(b, m, deterministic)
}
func (m *ThresholdParam) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ThresholdParam.Merge(m, src)
}
func (m *ThresholdParam) XXX_Size() int {
	return xxx_messageInfo_ThresholdParam.Size(m)
}
func (m *ThresholdParam) XXX_DiscardUnknown() {
	xxx_messageInfo_ThresholdParam.DiscardUnknown(m)
}

var xxx_messageInfo_ThresholdParam proto.InternalMessageInfo

func (m *ThresholdParam) GetOnValue() float32 {
	if m != nil {
		return m.OnValue
	}
	return 0
}

func (m *ThresholdParam) GetOffValue() float32 {
	if m != nil {
		return m.OffValue
	}
	return 0
}

func (m *ThresholdParam) GetThreshold() float32 {
	if m != nil {
		return m.Threshold
	}
	return 0
}

// A parameter that may change with node depth.
type DepthDependentParam struct {
	// Types that are valid to be assigned to ParamType:
	//	*DepthDependentParam_ConstantValue
	//	*DepthDependentParam_Linear
	//	*DepthDependentParam_Exponential
	//	*DepthDependentParam_Threshold
	ParamType            isDepthDependentParam_ParamType `protobuf_oneof:"ParamType"`
	XXX_NoUnkeyedLiteral struct{}                        `json:"-"`
	XXX_unrecognized     []byte                          `json:"-"`
	XXX_sizecache        int32                           `json:"-"`
}

func (m *DepthDependentParam) Reset()         { *m = DepthDependentParam{} }
func (m *DepthDependentParam) String() string { return proto.CompactTextString(m) }
func (*DepthDependentParam) ProtoMessage()    {}
func (*DepthDependentParam) Descriptor() ([]byte, []int) {
	return fileDescriptor_a700a4f06122ab7a, []int{5}
}

func (m *DepthDependentParam) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DepthDependentParam.Unmarshal(m, b)
}
func (m *DepthDependentParam) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DepthDependentParam.Marshal(b, m, deterministic)
}
func (m *DepthDependentParam) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DepthDependentParam.Merge(m, src)
}
func (m *DepthDependentParam) XXX_Size() int {
	return xxx_messageInfo_DepthDependentParam.Size(m)
}
func (m *DepthDependentParam) XXX_DiscardUnknown() {
	xxx_messageInfo_DepthDependentParam.DiscardUnknown(m)
}

var xxx_messageInfo_DepthDependentParam proto.InternalMessageInfo

type isDepthDependentParam_ParamType interface {
	isDepthDependentParam_ParamType()
}

type DepthDependentParam_ConstantValue struct {
	ConstantValue float32 `protobuf:"fixed32,1,opt,name=constant_value,json=constantValue,proto3,oneof"`
}

type DepthDependentParam_Linear struct {
	Linear *LinearParam `protobuf:"bytes,2,opt,name=linear,proto3,oneof"`
}

type DepthDependentParam_Exponential struct {
	Exponential *ExponentialParam `protobuf:"bytes,3,opt,name=exponential,proto3,oneof"`
}

type DepthDependentParam_Threshold struct {
	Threshold *ThresholdParam `protobuf:"bytes,4,opt,name=threshold,proto3,oneof"`
}

func (*DepthDependentParam_ConstantValue) isDepthDependentParam_ParamType() {}

func (*DepthDependentParam_Linear) isDepthDependentParam_ParamType() {}

func (*DepthDependentParam_Exponential) isDepthDependentParam_ParamType() {}

func (*DepthDependentParam_Threshold) isDepthDependentParam_ParamType() {}

func (m *DepthDependentParam) GetParamType() isDepthDependentParam_ParamType {
	if m != nil {
		return m.ParamType
	}
	return nil
}

func (m *DepthDependentParam) GetConstantValue() float32 {
	if x, ok := m.GetParamType().(*DepthDependentParam_ConstantValue); ok {
		return x.ConstantValue
	}
	return 0
}

func (m *DepthDependentParam) GetLinear() *LinearParam {
	if x, ok := m.GetParamType().(*DepthDependentParam_Linear); ok {
		return x.Linear
	}
	return nil
}

func (m *DepthDependentParam) GetExponential() *ExponentialParam {
	if x, ok := m.GetParamType().(*DepthDependentParam_Exponential); ok {
		return x.Exponential
	}
	return nil
}

func (m *DepthDependentParam) GetThreshold() *ThresholdParam {
	if x, ok := m.GetParamType().(*DepthDependentParam_Threshold); ok {
		return x.Threshold
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*DepthDependentParam) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*DepthDependentParam_ConstantValue)(nil),
		(*DepthDependentParam_Linear)(nil),
		(*DepthDependentParam_Exponential)(nil),
		(*DepthDependentParam_Threshold)(nil),
	}
}

type TensorForestParams struct {
	// ------------ Types that control training subsystems ------ //
	LeafType       LeafModelType       `protobuf:"varint,1,opt,name=leaf_type,json=leafType,proto3,enum=tensorflow.tensorforest.LeafModelType" json:"leaf_type,omitempty"`
	StatsType      StatsModelType      `protobuf:"varint,2,opt,name=stats_type,json=statsType,proto3,enum=tensorflow.tensorforest.StatsModelType" json:"stats_type,omitempty"`
	CollectionType SplitCollectionType `protobuf:"varint,3,opt,name=collection_type,json=collectionType,proto3,enum=tensorflow.tensorforest.SplitCollectionType" json:"collection_type,omitempty"`
	PruningType    *SplitPruningConfig `protobuf:"bytes,4,opt,name=pruning_type,json=pruningType,proto3" json:"pruning_type,omitempty"`
	FinishType     *SplitFinishConfig  `protobuf:"bytes,5,opt,name=finish_type,json=finishType,proto3" json:"finish_type,omitempty"`
	// --------- Parameters that can't change by definition --------------- //
	NumTrees           int32                              `protobuf:"varint,6,opt,name=num_trees,json=numTrees,proto3" json:"num_trees,omitempty"`
	MaxNodes           int32                              `protobuf:"varint,7,opt,name=max_nodes,json=maxNodes,proto3" json:"max_nodes,omitempty"`
	NumFeatures        int32                              `protobuf:"varint,21,opt,name=num_features,json=numFeatures,proto3" json:"num_features,omitempty"`
	InequalityTestType decision_trees.InequalityTest_Type `protobuf:"varint,19,opt,name=inequality_test_type,json=inequalityTestType,proto3,enum=tensorflow.decision_trees.InequalityTest_Type" json:"inequality_test_type,omitempty"`
	// Some booleans controlling execution
	IsRegression            bool `protobuf:"varint,8,opt,name=is_regression,json=isRegression,proto3" json:"is_regression,omitempty"`
	DropFinalClass          bool `protobuf:"varint,9,opt,name=drop_final_class,json=dropFinalClass,proto3" json:"drop_final_class,omitempty"`
	CollateExamples         bool `protobuf:"varint,10,opt,name=collate_examples,json=collateExamples,proto3" json:"collate_examples,omitempty"`
	CheckpointStats         bool `protobuf:"varint,11,opt,name=checkpoint_stats,json=checkpointStats,proto3" json:"checkpoint_stats,omitempty"`
	UseRunningStatsMethod   bool `protobuf:"varint,20,opt,name=use_running_stats_method,json=useRunningStatsMethod,proto3" json:"use_running_stats_method,omitempty"`
	InitializeAverageSplits bool `protobuf:"varint,22,opt,name=initialize_average_splits,json=initializeAverageSplits,proto3" json:"initialize_average_splits,omitempty"`
	InferenceTreePaths      bool `protobuf:"varint,23,opt,name=inference_tree_paths,json=inferenceTreePaths,proto3" json:"inference_tree_paths,omitempty"`
	// Number of classes (classification) or targets (regression)
	NumOutputs int32 `protobuf:"varint,12,opt,name=num_outputs,json=numOutputs,proto3" json:"num_outputs,omitempty"`
	// --------- Parameters that could be depth-dependent --------------- //
	NumSplitsToConsider *DepthDependentParam `protobuf:"bytes,13,opt,name=num_splits_to_consider,json=numSplitsToConsider,proto3" json:"num_splits_to_consider,omitempty"`
	SplitAfterSamples   *DepthDependentParam `protobuf:"bytes,14,opt,name=split_after_samples,json=splitAfterSamples,proto3" json:"split_after_samples,omitempty"`
	DominateFraction    *DepthDependentParam `protobuf:"bytes,15,opt,name=dominate_fraction,json=dominateFraction,proto3" json:"dominate_fraction,omitempty"`
	MinSplitSamples     *DepthDependentParam `protobuf:"bytes,18,opt,name=min_split_samples,json=minSplitSamples,proto3" json:"min_split_samples,omitempty"`
	// --------- Parameters for experimental features ---------------------- //
	GraphDir          string `protobuf:"bytes,16,opt,name=graph_dir,json=graphDir,proto3" json:"graph_dir,omitempty"`
	NumSelectFeatures int32  `protobuf:"varint,17,opt,name=num_select_features,json=numSelectFeatures,proto3" json:"num_select_features,omitempty"`
	// When using a FixedSizeSparseClassificationGrowStats, keep track of
	// this many classes.
	NumClassesToTrack    int32    `protobuf:"varint,24,opt,name=num_classes_to_track,json=numClassesToTrack,proto3" json:"num_classes_to_track,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TensorForestParams) Reset()         { *m = TensorForestParams{} }
func (m *TensorForestParams) String() string { return proto.CompactTextString(m) }
func (*TensorForestParams) ProtoMessage()    {}
func (*TensorForestParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_a700a4f06122ab7a, []int{6}
}

func (m *TensorForestParams) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TensorForestParams.Unmarshal(m, b)
}
func (m *TensorForestParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TensorForestParams.Marshal(b, m, deterministic)
}
func (m *TensorForestParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TensorForestParams.Merge(m, src)
}
func (m *TensorForestParams) XXX_Size() int {
	return xxx_messageInfo_TensorForestParams.Size(m)
}
func (m *TensorForestParams) XXX_DiscardUnknown() {
	xxx_messageInfo_TensorForestParams.DiscardUnknown(m)
}

var xxx_messageInfo_TensorForestParams proto.InternalMessageInfo

func (m *TensorForestParams) GetLeafType() LeafModelType {
	if m != nil {
		return m.LeafType
	}
	return LeafModelType_MODEL_DENSE_CLASSIFICATION
}

func (m *TensorForestParams) GetStatsType() StatsModelType {
	if m != nil {
		return m.StatsType
	}
	return StatsModelType_STATS_DENSE_GINI
}

func (m *TensorForestParams) GetCollectionType() SplitCollectionType {
	if m != nil {
		return m.CollectionType
	}
	return SplitCollectionType_COLLECTION_BASIC
}

func (m *TensorForestParams) GetPruningType() *SplitPruningConfig {
	if m != nil {
		return m.PruningType
	}
	return nil
}

func (m *TensorForestParams) GetFinishType() *SplitFinishConfig {
	if m != nil {
		return m.FinishType
	}
	return nil
}

func (m *TensorForestParams) GetNumTrees() int32 {
	if m != nil {
		return m.NumTrees
	}
	return 0
}

func (m *TensorForestParams) GetMaxNodes() int32 {
	if m != nil {
		return m.MaxNodes
	}
	return 0
}

func (m *TensorForestParams) GetNumFeatures() int32 {
	if m != nil {
		return m.NumFeatures
	}
	return 0
}

func (m *TensorForestParams) GetInequalityTestType() decision_trees.InequalityTest_Type {
	if m != nil {
		return m.InequalityTestType
	}
	return decision_trees.InequalityTest_LESS_OR_EQUAL
}

func (m *TensorForestParams) GetIsRegression() bool {
	if m != nil {
		return m.IsRegression
	}
	return false
}

func (m *TensorForestParams) GetDropFinalClass() bool {
	if m != nil {
		return m.DropFinalClass
	}
	return false
}

func (m *TensorForestParams) GetCollateExamples() bool {
	if m != nil {
		return m.CollateExamples
	}
	return false
}

func (m *TensorForestParams) GetCheckpointStats() bool {
	if m != nil {
		return m.CheckpointStats
	}
	return false
}

func (m *TensorForestParams) GetUseRunningStatsMethod() bool {
	if m != nil {
		return m.UseRunningStatsMethod
	}
	return false
}

func (m *TensorForestParams) GetInitializeAverageSplits() bool {
	if m != nil {
		return m.InitializeAverageSplits
	}
	return false
}

func (m *TensorForestParams) GetInferenceTreePaths() bool {
	if m != nil {
		return m.InferenceTreePaths
	}
	return false
}

func (m *TensorForestParams) GetNumOutputs() int32 {
	if m != nil {
		return m.NumOutputs
	}
	return 0
}

func (m *TensorForestParams) GetNumSplitsToConsider() *DepthDependentParam {
	if m != nil {
		return m.NumSplitsToConsider
	}
	return nil
}

func (m *TensorForestParams) GetSplitAfterSamples() *DepthDependentParam {
	if m != nil {
		return m.SplitAfterSamples
	}
	return nil
}

func (m *TensorForestParams) GetDominateFraction() *DepthDependentParam {
	if m != nil {
		return m.DominateFraction
	}
	return nil
}

func (m *TensorForestParams) GetMinSplitSamples() *DepthDependentParam {
	if m != nil {
		return m.MinSplitSamples
	}
	return nil
}

func (m *TensorForestParams) GetGraphDir() string {
	if m != nil {
		return m.GraphDir
	}
	return ""
}

func (m *TensorForestParams) GetNumSelectFeatures() int32 {
	if m != nil {
		return m.NumSelectFeatures
	}
	return 0
}

func (m *TensorForestParams) GetNumClassesToTrack() int32 {
	if m != nil {
		return m.NumClassesToTrack
	}
	return 0
}

func init() {
	proto.RegisterEnum("tensorflow.tensorforest.LeafModelType", LeafModelType_name, LeafModelType_value)
	proto.RegisterEnum("tensorflow.tensorforest.StatsModelType", StatsModelType_name, StatsModelType_value)
	proto.RegisterEnum("tensorflow.tensorforest.SplitCollectionType", SplitCollectionType_name, SplitCollectionType_value)
	proto.RegisterEnum("tensorflow.tensorforest.SplitPruningStrategyType", SplitPruningStrategyType_name, SplitPruningStrategyType_value)
	proto.RegisterEnum("tensorflow.tensorforest.SplitFinishStrategyType", SplitFinishStrategyType_name, SplitFinishStrategyType_value)
	proto.RegisterType((*SplitPruningConfig)(nil), "tensorflow.tensorforest.SplitPruningConfig")
	proto.RegisterType((*SplitFinishConfig)(nil), "tensorflow.tensorforest.SplitFinishConfig")
	proto.RegisterType((*LinearParam)(nil), "tensorflow.tensorforest.LinearParam")
	proto.RegisterType((*ExponentialParam)(nil), "tensorflow.tensorforest.ExponentialParam")
	proto.RegisterType((*ThresholdParam)(nil), "tensorflow.tensorforest.ThresholdParam")
	proto.RegisterType((*DepthDependentParam)(nil), "tensorflow.tensorforest.DepthDependentParam")
	proto.RegisterType((*TensorForestParams)(nil), "tensorflow.tensorforest.TensorForestParams")
}

func init() {
	proto.RegisterFile("tensorflow/contrib/tensor_forest/proto/tensor_forest_params.proto", fileDescriptor_a700a4f06122ab7a)
}

var fileDescriptor_a700a4f06122ab7a = []byte{
	// 1461 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x57, 0xdd, 0x6e, 0xe3, 0xc6,
	0x15, 0x16, 0x6d, 0xef, 0xae, 0x75, 0xe4, 0x1f, 0x7a, 0xfc, 0xc7, 0x5d, 0x07, 0xbb, 0xae, 0x13,
	0x34, 0x8e, 0x1b, 0xc8, 0x1b, 0xf7, 0xa2, 0x40, 0x2f, 0x8a, 0xca, 0x12, 0x65, 0x11, 0x91, 0x25,
	0x95, 0xa4, 0x83, 0x34, 0x28, 0x30, 0xa5, 0xa5, 0xa1, 0x34, 0x08, 0x39, 0x64, 0xc9, 0xa1, 0x6b,
	0xb7, 0xd7, 0xbd, 0xef, 0x55, 0x5f, 0xa0, 0xe8, 0x13, 0x14, 0xbd, 0xe8, 0xdb, 0x15, 0x73, 0x86,
	0xfa, 0x4b, 0xad, 0x20, 0xf0, 0xdd, 0xf0, 0x3b, 0xe7, 0x7c, 0xe7, 0x9b, 0x39, 0x33, 0x67, 0x86,
	0xd0, 0x90, 0x4c, 0xe4, 0x49, 0x16, 0x46, 0xc9, 0x9f, 0x2f, 0x87, 0x89, 0x90, 0x19, 0xbf, 0xbf,
	0xd4, 0x10, 0x0d, 0x93, 0x8c, 0xe5, 0xf2, 0x32, 0xcd, 0x12, 0x99, 0x2c, 0x63, 0x34, 0x0d, 0xb2,
	0x20, 0xce, 0xeb, 0x68, 0x22, 0xc7, 0x73, 0x8a, 0x7a, 0x39, 0x44, 0xaf, 0x77, 0xbf, 0x7d, 0x86,
	0x7b, 0xc4, 0x86, 0x3c, 0xe7, 0x89, 0xa0, 0x32, 0x63, 0x2c, 0x2f, 0xc9, 0xc7, 0x4c, 0xb0, 0x8c,
	0x0f, 0x11, 0xa3, 0x71, 0x32, 0x62, 0x91, 0xa6, 0x3e, 0xfb, 0xaf, 0x01, 0xc4, 0x4b, 0x23, 0x2e,
	0x07, 0x59, 0x21, 0xb8, 0x18, 0x37, 0x13, 0x11, 0xf2, 0x31, 0xf9, 0x03, 0xec, 0xa7, 0x59, 0x21,
	0x18, 0x65, 0x0f, 0x2c, 0x7b, 0xa2, 0x79, 0x10, 0xa7, 0x11, 0xcb, 0x2d, 0xe3, 0xd4, 0x38, 0xaf,
	0x5d, 0x7d, 0x59, 0x5f, 0xa1, 0xa7, 0xde, 0x62, 0xa9, 0x9c, 0xb4, 0x58, 0xca, 0xc4, 0x88, 0x09,
	0x39, 0x50, 0x73, 0x70, 0xf7, 0x90, 0xc8, 0x56, 0x3c, 0x9e, 0xa6, 0x21, 0x36, 0x6c, 0xc8, 0xa7,
	0x94, 0x59, 0x6b, 0xa7, 0xc6, 0xf9, 0xce, 0xd5, 0x57, 0x2b, 0xe9, 0x16, 0x85, 0x79, 0x32, 0x0b,
	0x24, 0x1b, 0x3f, 0xf9, 0x4f, 0x29, 0x73, 0x31, 0xfc, 0xec, 0xdf, 0x06, 0xec, 0xa1, 0x4b, 0x9b,
	0x0b, 0x9e, 0x4f, 0x4a, 0xe9, 0xdf, 0xc2, 0xde, 0x70, 0xc2, 0x86, 0xdf, 0x4f, 0xa5, 0x4b, 0x96,
	0xbe, 0x4c, 0xf8, 0x2e, 0xd2, 0x68, 0xe1, 0x8a, 0x84, 0xb4, 0x96, 0x64, 0x7f, 0xfc, 0x71, 0xd9,
	0x5a, 0xd3, 0x33, 0xaa, 0x1f, 0xa0, 0xd6, 0xe5, 0x82, 0x05, 0x19, 0x66, 0x21, 0x07, 0xf0, 0x2a,
	0x8f, 0x92, 0x94, 0xa1, 0xc4, 0x35, 0x57, 0x7f, 0x90, 0x0f, 0x50, 0x7b, 0xa2, 0x5c, 0x48, 0x96,
	0x0d, 0x59, 0x2a, 0x31, 0xe3, 0x9a, 0x0b, 0x4f, 0xce, 0x14, 0x21, 0xc7, 0xf0, 0x26, 0xe6, 0x82,
	0x3e, 0x04, 0x91, 0xb5, 0x8e, 0xc6, 0xd7, 0x31, 0x17, 0xdf, 0x04, 0x11, 0x1a, 0x82, 0x47, 0x34,
	0x6c, 0x94, 0x86, 0xe0, 0xf1, 0x9b, 0x20, 0x3a, 0xfb, 0x9b, 0x01, 0xa6, 0xfd, 0x98, 0x26, 0x82,
	0x09, 0xc9, 0x83, 0x48, 0x67, 0x27, 0xb0, 0x71, 0xcf, 0x83, 0xbc, 0x4c, 0x8e, 0x63, 0xc4, 0x82,
	0x9c, 0x95, 0x49, 0x71, 0x4c, 0xde, 0x03, 0xc4, 0x45, 0x24, 0x79, 0x1a, 0x71, 0x96, 0x95, 0x19,
	0x17, 0x10, 0xf2, 0x05, 0x98, 0x23, 0xb5, 0x84, 0x74, 0xc1, 0x4b, 0xa7, 0xdf, 0x45, 0xfc, 0x76,
	0x06, 0x9f, 0x85, 0xb0, 0xe3, 0x4f, 0x32, 0x96, 0x4f, 0x92, 0x68, 0xa4, 0x45, 0xbc, 0x85, 0xcd,
	0x04, 0xa7, 0x52, 0x4c, 0x57, 0xe1, 0x4d, 0xa2, 0xe6, 0x52, 0x30, 0x72, 0x02, 0xd5, 0x24, 0x0c,
	0x4b, 0x9b, 0x16, 0xb4, 0x99, 0x84, 0xa1, 0x36, 0x7e, 0x02, 0x55, 0x39, 0x65, 0x2a, 0x35, 0xcd,
	0x81, 0xb3, 0x7f, 0xae, 0xc1, 0xfe, 0x33, 0x65, 0x25, 0x9f, 0xc3, 0xce, 0x30, 0x11, 0xb9, 0x0c,
	0x84, 0x5c, 0xcc, 0xd9, 0xa9, 0xb8, 0xdb, 0x53, 0x5c, 0xd3, 0xff, 0x06, 0x5e, 0x47, 0x58, 0x28,
	0x4c, 0x5c, 0xbb, 0xfa, 0x6c, 0x65, 0xc1, 0x17, 0xea, 0xd9, 0xa9, 0xb8, 0x65, 0x14, 0xb9, 0x85,
	0x1a, 0x9b, 0xaf, 0x37, 0x0a, 0xac, 0x5d, 0x7d, 0xb1, 0x92, 0xe4, 0x87, 0xb5, 0xe9, 0x54, 0xdc,
	0xc5, 0x78, 0x72, 0xb3, 0x38, 0xdb, 0x0d, 0x24, 0xfb, 0x7c, 0x25, 0xd9, 0xf2, 0x0a, 0x77, 0x2a,
	0x0b, 0x0b, 0x73, 0x5d, 0x83, 0x2a, 0xa2, 0x6a, 0x4f, 0x9e, 0xfd, 0xa7, 0x06, 0xc4, 0xc7, 0xc8,
	0x36, 0x46, 0xa2, 0x25, 0x27, 0x4d, 0xa8, 0x46, 0x2c, 0x08, 0x29, 0xee, 0x77, 0x03, 0xf7, 0xfb,
	0xcf, 0x57, 0x4f, 0x9f, 0x05, 0xe1, 0xad, 0xea, 0x29, 0xb8, 0xcb, 0x37, 0x55, 0xa0, 0x1a, 0x91,
	0x36, 0x40, 0x2e, 0x03, 0x99, 0xd3, 0x85, 0x53, 0xb3, 0x5a, 0xb2, 0xa7, 0x5c, 0xe7, 0x34, 0x55,
	0x0c, 0x45, 0x9e, 0x3b, 0xd8, 0x1d, 0x26, 0x51, 0xc4, 0x86, 0x12, 0xdb, 0x9a, 0x22, 0x5b, 0x47,
	0xb2, 0x2f, 0x7f, 0xfc, 0x08, 0x36, 0x67, 0x41, 0xc8, 0xb8, 0x33, 0x5c, 0xfa, 0x26, 0x3d, 0xd8,
	0x4a, 0x75, 0x6f, 0xd1, 0x9c, 0x7a, 0x4d, 0x7f, 0xf1, 0x93, 0xba, 0x91, 0xee, 0x35, 0x6e, 0xad,
	0x24, 0x40, 0xbe, 0xaf, 0xa1, 0x16, 0xe2, 0xa1, 0xd7, 0x74, 0xaf, 0x90, 0xee, 0xe2, 0xa7, 0x74,
	0x89, 0x92, 0x0d, 0x74, 0x38, 0x92, 0x9d, 0x40, 0x55, 0x14, 0xb1, 0xee, 0xe1, 0xd6, 0xeb, 0x53,
	0xe3, 0xfc, 0x95, 0xbb, 0x29, 0x8a, 0xd8, 0x57, 0xdf, 0xca, 0xa8, 0xce, 0xb8, 0x48, 0x46, 0x2c,
	0xb7, 0xde, 0x68, 0x63, 0x1c, 0x3c, 0xf6, 0xd4, 0x37, 0xf9, 0x19, 0x6c, 0xa9, 0xc8, 0x90, 0x05,
	0xb2, 0xc8, 0x58, 0x6e, 0x1d, 0xa2, 0xbd, 0x26, 0x8a, 0xb8, 0x5d, 0x42, 0xe4, 0x8f, 0x70, 0xc0,
	0x05, 0xfb, 0x53, 0x11, 0x44, 0x5c, 0x3e, 0x51, 0xa9, 0xee, 0x1b, 0x94, 0xbc, 0x8f, 0xab, 0x5a,
	0x5f, 0x94, 0xbc, 0x7c, 0x9b, 0xd4, 0x9d, 0x59, 0x98, 0x8f, 0xdb, 0x4c, 0xad, 0x2b, 0xe1, 0x4b,
	0x20, 0xca, 0xff, 0x14, 0xb6, 0x79, 0x4e, 0x33, 0x36, 0xce, 0x58, 0xae, 0xc2, 0xad, 0xcd, 0x53,
	0xe3, 0x7c, 0xd3, 0xdd, 0xe2, 0xb9, 0x3b, 0xc3, 0xc8, 0x39, 0x98, 0xa3, 0x2c, 0x49, 0x69, 0xc8,
	0x45, 0x10, 0xd1, 0x61, 0x14, 0xe4, 0xb9, 0x55, 0x45, 0xbf, 0x1d, 0x85, 0xb7, 0x15, 0xdc, 0x54,
	0xa8, 0x6a, 0x2f, 0xaa, 0x78, 0x81, 0x64, 0x94, 0x3d, 0x96, 0x77, 0x11, 0xa0, 0xe7, 0x6e, 0x89,
	0xdb, 0x25, 0x8c, 0xae, 0xaa, 0x6f, 0xa7, 0x09, 0x17, 0x92, 0xe2, 0x26, 0xb2, 0x6a, 0xa5, 0xeb,
	0x0c, 0xc7, 0xbd, 0x46, 0x7e, 0x05, 0x56, 0x91, 0x33, 0x9a, 0x15, 0x02, 0x37, 0x81, 0xde, 0xab,
	0x31, 0x93, 0x93, 0x64, 0x64, 0x1d, 0x60, 0xc8, 0x61, 0x91, 0x33, 0x57, 0x9b, 0xf5, 0xf6, 0x44,
	0x23, 0xf9, 0x35, 0xbc, 0xe5, 0x82, 0xab, 0x53, 0xc9, 0xff, 0xc2, 0x68, 0xf0, 0xc0, 0xb2, 0x60,
	0xcc, 0x68, 0xae, 0x0a, 0x9a, 0x5b, 0x47, 0x18, 0x79, 0x3c, 0x77, 0x68, 0x68, 0x3b, 0xd6, 0x3b,
	0x27, 0x1f, 0xd5, 0xda, 0x87, 0x2c, 0x63, 0x62, 0xc8, 0xf4, 0x75, 0x9c, 0x06, 0x72, 0x92, 0x5b,
	0xc7, 0x18, 0x46, 0x66, 0x36, 0x55, 0xe9, 0x81, 0xb2, 0xa8, 0xbb, 0x40, 0x15, 0x34, 0x29, 0x64,
	0x5a, 0xc8, 0xdc, 0xda, 0xc2, 0x7a, 0x82, 0x28, 0xe2, 0xbe, 0x46, 0x48, 0x00, 0x47, 0xca, 0x41,
	0xe7, 0xa7, 0x32, 0xa1, 0xaa, 0x8f, 0xf1, 0x11, 0xcb, 0xac, 0xed, 0x17, 0x5c, 0x7b, 0xfb, 0xa2,
	0x88, 0xb5, 0x56, 0x3f, 0x69, 0x96, 0x44, 0xea, 0x3d, 0x80, 0xf4, 0x34, 0x08, 0x25, 0xcb, 0x66,
	0xef, 0x81, 0x9d, 0x97, 0xbc, 0x07, 0x90, 0xa8, 0xa1, 0x78, 0xa6, 0xef, 0x81, 0xdf, 0xc3, 0xde,
	0x28, 0x89, 0xb9, 0x50, 0xf5, 0x0d, 0xb3, 0x00, 0x8f, 0xa8, 0xb5, 0xfb, 0x02, 0x6e, 0x73, 0x4a,
	0xd3, 0x2e, 0x59, 0xd4, 0x6b, 0x40, 0xdd, 0x93, 0x5a, 0xfc, 0x54, 0x36, 0x79, 0xc9, 0x6b, 0x20,
	0xe6, 0x02, 0x97, 0x65, 0x2a, 0xfa, 0x04, 0xaa, 0xe3, 0x2c, 0x48, 0x27, 0x74, 0xc4, 0x33, 0xcb,
	0x3c, 0x35, 0xce, 0xab, 0xee, 0x26, 0x02, 0x2d, 0x9e, 0x91, 0x3a, 0xec, 0x63, 0x49, 0x98, 0x6a,
	0x38, 0xf3, 0xb3, 0xb8, 0x87, 0xb5, 0xdb, 0x53, 0x2b, 0x8c, 0x96, 0xd9, 0x89, 0xbc, 0x84, 0x03,
	0xe5, 0x8f, 0x67, 0x80, 0x61, 0x0d, 0x65, 0x16, 0x0c, 0xbf, 0xb7, 0xac, 0x59, 0x40, 0x53, 0x9b,
	0xfc, 0xc4, 0x57, 0x86, 0x8b, 0xbf, 0x1b, 0xb0, 0xbd, 0xd4, 0x77, 0xc9, 0x7b, 0x78, 0x77, 0xdb,
	0x6f, 0xd9, 0x5d, 0xda, 0xb2, 0x7b, 0x9e, 0x4d, 0x9b, 0xdd, 0x86, 0xe7, 0x39, 0x6d, 0xa7, 0xd9,
	0xf0, 0x9d, 0x7e, 0xcf, 0xac, 0x90, 0x0f, 0x70, 0xa2, 0xed, 0xde, 0xa0, 0xe1, 0xfe, 0xbf, 0x83,
	0x41, 0x0e, 0xc0, 0xd4, 0x0e, 0xae, 0x7d, 0xe3, 0xda, 0x9e, 0xa7, 0xd0, 0x35, 0x72, 0x0e, 0x9f,
	0x2d, 0x85, 0xf5, 0xdd, 0xe7, 0x13, 0xac, 0x5f, 0xfc, 0xcb, 0x80, 0x9d, 0xe5, 0x26, 0xae, 0x28,
	0x3d, 0xbf, 0xe1, 0x7b, 0x65, 0xc8, 0x8d, 0xd3, 0x73, 0xcc, 0x0a, 0x39, 0x84, 0x3d, 0x8d, 0x96,
	0x94, 0x08, 0x1b, 0xe4, 0x0c, 0xde, 0x6b, 0xb8, 0x6b, 0x37, 0x3c, 0x9f, 0x7a, 0xbf, 0xbb, 0x6b,
	0xb8, 0xb6, 0xb7, 0xac, 0xe6, 0x14, 0x3e, 0x59, 0x0a, 0xf5, 0x3b, 0x76, 0x6f, 0x91, 0x7c, 0x7d,
	0xee, 0xd1, 0x76, 0xbe, 0xb5, 0x5b, 0xd4, 0x73, 0xbe, 0xb3, 0x97, 0xf2, 0x6c, 0x5c, 0x74, 0x60,
	0xff, 0x99, 0xeb, 0x41, 0x69, 0x6d, 0xf6, 0xbb, 0x5d, 0xbb, 0xa9, 0xa6, 0x43, 0xaf, 0x1b, 0x9e,
	0xd3, 0x34, 0x2b, 0xe4, 0x04, 0x8e, 0x6f, 0xdc, 0xc6, 0xa0, 0x43, 0xdd, 0xbb, 0x5e, 0xcf, 0x76,
	0xe9, 0xdc, 0xc5, 0x34, 0x2e, 0xfe, 0x61, 0x80, 0xb5, 0xea, 0x8d, 0x8a, 0x73, 0x1f, 0x74, 0x1d,
	0x9f, 0x0e, 0xdc, 0xbb, 0x9e, 0x4d, 0x7b, 0xfd, 0x9e, 0x6d, 0x56, 0x7e, 0x88, 0x76, 0x1a, 0xdd,
	0xb6, 0x69, 0x90, 0x63, 0xd8, 0x5f, 0x44, 0xd5, 0xcc, 0x7d, 0xdb, 0x35, 0xd7, 0xc8, 0x3b, 0x38,
	0x5a, 0x34, 0x7c, 0xf5, 0x91, 0x0e, 0x6c, 0xb7, 0x69, 0xf7, 0x7c, 0x73, 0x9d, 0xbc, 0x85, 0xc3,
	0x25, 0xaa, 0xbe, 0xdd, 0x6e, 0xb7, 0x9c, 0xde, 0x8d, 0xb9, 0x71, 0xf1, 0x57, 0x38, 0x5e, 0xf1,
	0x08, 0x25, 0x47, 0x40, 0x74, 0x54, 0xdb, 0xe9, 0x39, 0x5e, 0x67, 0x36, 0xd1, 0x4f, 0xe1, 0xc3,
	0x12, 0xde, 0xea, 0xdf, 0x3a, 0xbd, 0x86, 0xbf, 0xc8, 0xbb, 0xb6, 0xda, 0xe9, 0xba, 0xdf, 0xf7,
	0x3d, 0xdf, 0x6d, 0x0c, 0xcc, 0xf5, 0xeb, 0xaf, 0xbf, 0x73, 0xc6, 0x5c, 0x4e, 0x8a, 0xfb, 0xfa,
	0x30, 0x89, 0x2f, 0x17, 0xfe, 0x50, 0x9e, 0x1f, 0x8e, 0x93, 0xcb, 0x61, 0x92, 0xb1, 0xe7, 0xff,
	0x8d, 0xee, 0x5f, 0xe3, 0x6f, 0xca, 0x2f, 0xff, 0x17, 0x00, 0x00, 0xff, 0xff, 0xab, 0x05, 0x0d,
	0x57, 0x46, 0x0d, 0x00, 0x00,
}
