// Code generated by protoc-gen-go. DO NOT EDIT.
// source: tensorflow/core/debug/debug_service.proto

package debug

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	profiler "github.com/tensorflow/tensorflow/tensorflow/go/core/core/profiler"
	util "github.com/tensorflow/tensorflow/tensorflow/go/core/core/util"
	framework "github.com/tensorflow/tensorflow/tensorflow/go/core/framework"
	protobuf "github.com/tensorflow/tensorflow/tensorflow/go/core/protobuf"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type EventReply_DebugOpStateChange_State int32

const (
	EventReply_DebugOpStateChange_STATE_UNSPECIFIED EventReply_DebugOpStateChange_State = 0
	EventReply_DebugOpStateChange_DISABLED          EventReply_DebugOpStateChange_State = 1
	EventReply_DebugOpStateChange_READ_ONLY         EventReply_DebugOpStateChange_State = 2
	EventReply_DebugOpStateChange_READ_WRITE        EventReply_DebugOpStateChange_State = 3
)

var EventReply_DebugOpStateChange_State_name = map[int32]string{
	0: "STATE_UNSPECIFIED",
	1: "DISABLED",
	2: "READ_ONLY",
	3: "READ_WRITE",
}

var EventReply_DebugOpStateChange_State_value = map[string]int32{
	"STATE_UNSPECIFIED": 0,
	"DISABLED":          1,
	"READ_ONLY":         2,
	"READ_WRITE":        3,
}

func (x EventReply_DebugOpStateChange_State) String() string {
	return proto.EnumName(EventReply_DebugOpStateChange_State_name, int32(x))
}

func (EventReply_DebugOpStateChange_State) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f7c954ada9cef18d, []int{0, 0, 0}
}

type CallTraceback_CallType int32

const (
	CallTraceback_UNSPECIFIED     CallTraceback_CallType = 0
	CallTraceback_GRAPH_EXECUTION CallTraceback_CallType = 1
	CallTraceback_EAGER_EXECUTION CallTraceback_CallType = 2
)

var CallTraceback_CallType_name = map[int32]string{
	0: "UNSPECIFIED",
	1: "GRAPH_EXECUTION",
	2: "EAGER_EXECUTION",
}

var CallTraceback_CallType_value = map[string]int32{
	"UNSPECIFIED":     0,
	"GRAPH_EXECUTION": 1,
	"EAGER_EXECUTION": 2,
}

func (x CallTraceback_CallType) String() string {
	return proto.EnumName(CallTraceback_CallType_name, int32(x))
}

func (CallTraceback_CallType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f7c954ada9cef18d, []int{1, 0}
}

// Reply message from EventListener to the client, i.e., to the source of the
// Event protocol buffers, e.g., debug ops inserted by a debugged runtime to a
// TensorFlow graph being executed.
type EventReply struct {
	DebugOpStateChanges []*EventReply_DebugOpStateChange `protobuf:"bytes,1,rep,name=debug_op_state_changes,json=debugOpStateChanges,proto3" json:"debug_op_state_changes,omitempty"`
	// New tensor value to override the current tensor value with.
	Tensor               *framework.TensorProto `protobuf:"bytes,2,opt,name=tensor,proto3" json:"tensor,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *EventReply) Reset()         { *m = EventReply{} }
func (m *EventReply) String() string { return proto.CompactTextString(m) }
func (*EventReply) ProtoMessage()    {}
func (*EventReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_f7c954ada9cef18d, []int{0}
}

func (m *EventReply) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_EventReply.Unmarshal(m, b)
}
func (m *EventReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_EventReply.Marshal(b, m, deterministic)
}
func (m *EventReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventReply.Merge(m, src)
}
func (m *EventReply) XXX_Size() int {
	return xxx_messageInfo_EventReply.Size(m)
}
func (m *EventReply) XXX_DiscardUnknown() {
	xxx_messageInfo_EventReply.DiscardUnknown(m)
}

var xxx_messageInfo_EventReply proto.InternalMessageInfo

func (m *EventReply) GetDebugOpStateChanges() []*EventReply_DebugOpStateChange {
	if m != nil {
		return m.DebugOpStateChanges
	}
	return nil
}

func (m *EventReply) GetTensor() *framework.TensorProto {
	if m != nil {
		return m.Tensor
	}
	return nil
}

type EventReply_DebugOpStateChange struct {
	State                EventReply_DebugOpStateChange_State `protobuf:"varint,1,opt,name=state,proto3,enum=tensorflow.EventReply_DebugOpStateChange_State" json:"state,omitempty"`
	NodeName             string                              `protobuf:"bytes,2,opt,name=node_name,json=nodeName,proto3" json:"node_name,omitempty"`
	OutputSlot           int32                               `protobuf:"varint,3,opt,name=output_slot,json=outputSlot,proto3" json:"output_slot,omitempty"`
	DebugOp              string                              `protobuf:"bytes,4,opt,name=debug_op,json=debugOp,proto3" json:"debug_op,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                            `json:"-"`
	XXX_unrecognized     []byte                              `json:"-"`
	XXX_sizecache        int32                               `json:"-"`
}

func (m *EventReply_DebugOpStateChange) Reset()         { *m = EventReply_DebugOpStateChange{} }
func (m *EventReply_DebugOpStateChange) String() string { return proto.CompactTextString(m) }
func (*EventReply_DebugOpStateChange) ProtoMessage()    {}
func (*EventReply_DebugOpStateChange) Descriptor() ([]byte, []int) {
	return fileDescriptor_f7c954ada9cef18d, []int{0, 0}
}

func (m *EventReply_DebugOpStateChange) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_EventReply_DebugOpStateChange.Unmarshal(m, b)
}
func (m *EventReply_DebugOpStateChange) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_EventReply_DebugOpStateChange.Marshal(b, m, deterministic)
}
func (m *EventReply_DebugOpStateChange) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventReply_DebugOpStateChange.Merge(m, src)
}
func (m *EventReply_DebugOpStateChange) XXX_Size() int {
	return xxx_messageInfo_EventReply_DebugOpStateChange.Size(m)
}
func (m *EventReply_DebugOpStateChange) XXX_DiscardUnknown() {
	xxx_messageInfo_EventReply_DebugOpStateChange.DiscardUnknown(m)
}

var xxx_messageInfo_EventReply_DebugOpStateChange proto.InternalMessageInfo

func (m *EventReply_DebugOpStateChange) GetState() EventReply_DebugOpStateChange_State {
	if m != nil {
		return m.State
	}
	return EventReply_DebugOpStateChange_STATE_UNSPECIFIED
}

func (m *EventReply_DebugOpStateChange) GetNodeName() string {
	if m != nil {
		return m.NodeName
	}
	return ""
}

func (m *EventReply_DebugOpStateChange) GetOutputSlot() int32 {
	if m != nil {
		return m.OutputSlot
	}
	return 0
}

func (m *EventReply_DebugOpStateChange) GetDebugOp() string {
	if m != nil {
		return m.DebugOp
	}
	return ""
}

// Data on the traceback of a debugged call, e.g., a Session.run() call, or the
// execution of an eager operation.
type CallTraceback struct {
	CallType CallTraceback_CallType `protobuf:"varint,1,opt,name=call_type,json=callType,proto3,enum=tensorflow.CallTraceback_CallType" json:"call_type,omitempty"`
	// A key for the call. For example, for graph execution, this is a key
	// consisting of the names of the fed and fetched tensors.
	CallKey string `protobuf:"bytes,2,opt,name=call_key,json=callKey,proto3" json:"call_key,omitempty"`
	// Traceback stack for the origin of the call event.
	// For graph execution, this is the stack of the Session.run() call.
	// For eager execution, this is the stack of the Python line that invokes
	// the execution of the eager op.
	OriginStack *profiler.CodeDef `protobuf:"bytes,3,opt,name=origin_stack,json=originStack,proto3" json:"origin_stack,omitempty"`
	// Keeps track of the mapping from integer IDs in `origin_stack` to actual
	// string values (e.g., file paths, function names).
	OriginIdToString map[int64]string `protobuf:"bytes,4,rep,name=origin_id_to_string,json=originIdToString,proto3" json:"origin_id_to_string,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Traceback for the graph (if any) involved in the call.
	GraphTraceback *profiler.OpLogProto `protobuf:"bytes,5,opt,name=graph_traceback,json=graphTraceback,proto3" json:"graph_traceback,omitempty"`
	// Version of the graph in `graph_traceback` (if any).
	GraphVersion         int64    `protobuf:"varint,6,opt,name=graph_version,json=graphVersion,proto3" json:"graph_version,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CallTraceback) Reset()         { *m = CallTraceback{} }
func (m *CallTraceback) String() string { return proto.CompactTextString(m) }
func (*CallTraceback) ProtoMessage()    {}
func (*CallTraceback) Descriptor() ([]byte, []int) {
	return fileDescriptor_f7c954ada9cef18d, []int{1}
}

func (m *CallTraceback) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CallTraceback.Unmarshal(m, b)
}
func (m *CallTraceback) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CallTraceback.Marshal(b, m, deterministic)
}
func (m *CallTraceback) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CallTraceback.Merge(m, src)
}
func (m *CallTraceback) XXX_Size() int {
	return xxx_messageInfo_CallTraceback.Size(m)
}
func (m *CallTraceback) XXX_DiscardUnknown() {
	xxx_messageInfo_CallTraceback.DiscardUnknown(m)
}

var xxx_messageInfo_CallTraceback proto.InternalMessageInfo

func (m *CallTraceback) GetCallType() CallTraceback_CallType {
	if m != nil {
		return m.CallType
	}
	return CallTraceback_UNSPECIFIED
}

func (m *CallTraceback) GetCallKey() string {
	if m != nil {
		return m.CallKey
	}
	return ""
}

func (m *CallTraceback) GetOriginStack() *profiler.CodeDef {
	if m != nil {
		return m.OriginStack
	}
	return nil
}

func (m *CallTraceback) GetOriginIdToString() map[int64]string {
	if m != nil {
		return m.OriginIdToString
	}
	return nil
}

func (m *CallTraceback) GetGraphTraceback() *profiler.OpLogProto {
	if m != nil {
		return m.GraphTraceback
	}
	return nil
}

func (m *CallTraceback) GetGraphVersion() int64 {
	if m != nil {
		return m.GraphVersion
	}
	return 0
}

func init() {
	proto.RegisterEnum("tensorflow.EventReply_DebugOpStateChange_State", EventReply_DebugOpStateChange_State_name, EventReply_DebugOpStateChange_State_value)
	proto.RegisterEnum("tensorflow.CallTraceback_CallType", CallTraceback_CallType_name, CallTraceback_CallType_value)
	proto.RegisterType((*EventReply)(nil), "tensorflow.EventReply")
	proto.RegisterType((*EventReply_DebugOpStateChange)(nil), "tensorflow.EventReply.DebugOpStateChange")
	proto.RegisterType((*CallTraceback)(nil), "tensorflow.CallTraceback")
	proto.RegisterMapType((map[int64]string)(nil), "tensorflow.CallTraceback.OriginIdToStringEntry")
}

func init() {
	proto.RegisterFile("tensorflow/core/debug/debug_service.proto", fileDescriptor_f7c954ada9cef18d)
}

var fileDescriptor_f7c954ada9cef18d = []byte{
	// 722 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x54, 0x5d, 0x6f, 0xda, 0x48,
	0x14, 0x5d, 0x43, 0x48, 0xe0, 0x12, 0x3e, 0x32, 0xd9, 0x64, 0x1d, 0x56, 0xab, 0x20, 0xb6, 0xaa,
	0xc8, 0x0b, 0xae, 0xe8, 0x4b, 0xd5, 0xaa, 0x1f, 0x04, 0x9c, 0x94, 0x06, 0x41, 0x64, 0x93, 0x7e,
	0x3d, 0xc4, 0x32, 0x66, 0x70, 0x2c, 0x8c, 0xc7, 0x1a, 0x8f, 0x89, 0x78, 0xac, 0xfa, 0x4b, 0xfa,
	0xc3, 0xfa, 0x5f, 0xaa, 0x99, 0x81, 0x42, 0x02, 0x48, 0x7d, 0x89, 0xee, 0x3d, 0x39, 0xe7, 0x70,
	0xe6, 0xfa, 0xce, 0xc0, 0x19, 0xc3, 0x41, 0x44, 0xe8, 0xc8, 0x27, 0xf7, 0x9a, 0x43, 0x28, 0xd6,
	0x86, 0x78, 0x10, 0xbb, 0xf2, 0xaf, 0x15, 0x61, 0x3a, 0xf5, 0x1c, 0x5c, 0x0b, 0x29, 0x61, 0x04,
	0xc1, 0x92, 0x5a, 0x7a, 0xfa, 0x58, 0x36, 0xa2, 0xf6, 0x04, 0xdf, 0x13, 0x3a, 0xd6, 0xe4, 0x7f,
	0xa4, 0xa6, 0xb4, 0x66, 0x1f, 0x52, 0x32, 0xf2, 0x7c, 0x4c, 0x35, 0x36, 0xe2, 0xa5, 0xe5, 0x13,
	0x77, 0x4e, 0x7d, 0xb2, 0x81, 0xca, 0xc8, 0x20, 0x1e, 0xc9, 0x30, 0x73, 0x56, 0xf9, 0x31, 0x2b,
	0x66, 0x9e, 0xaf, 0xe1, 0x29, 0x0e, 0x98, 0x64, 0x54, 0x7e, 0x24, 0x01, 0x74, 0xde, 0x1b, 0x38,
	0xf4, 0x67, 0xe8, 0x16, 0x8e, 0xe5, 0x61, 0x48, 0x68, 0x45, 0xcc, 0x66, 0xd8, 0x72, 0xee, 0xec,
	0xc0, 0xc5, 0x91, 0xaa, 0x94, 0x93, 0xd5, 0x6c, 0xfd, 0xac, 0xb6, 0x74, 0xac, 0x2d, 0x75, 0xb5,
	0x16, 0x17, 0xf5, 0x42, 0x93, 0x4b, 0x9a, 0x42, 0x61, 0x1c, 0x0e, 0xd7, 0xb0, 0x08, 0x69, 0xb0,
	0x2b, 0x0d, 0xd4, 0x44, 0x59, 0xa9, 0x66, 0xeb, 0xff, 0xac, 0xfa, 0xf5, 0x45, 0x79, 0xcd, 0x73,
	0x19, 0x73, 0x5a, 0xe9, 0x5b, 0x02, 0xd0, 0xba, 0x39, 0xd2, 0x21, 0x25, 0xe2, 0xa9, 0x4a, 0x59,
	0xa9, 0xe6, 0xeb, 0xda, 0x1f, 0xc7, 0xaa, 0x89, 0xda, 0x90, 0x6a, 0xf4, 0x2f, 0x64, 0x02, 0x32,
	0xc4, 0x56, 0x60, 0x4f, 0xb0, 0x48, 0x94, 0x31, 0xd2, 0x1c, 0xe8, 0xda, 0x13, 0x8c, 0x4e, 0x21,
	0x4b, 0x62, 0x16, 0xc6, 0xcc, 0x8a, 0x7c, 0xc2, 0xd4, 0x64, 0x59, 0xa9, 0xa6, 0x0c, 0x90, 0x90,
	0xe9, 0x13, 0x86, 0x4e, 0x20, 0xbd, 0x18, 0x96, 0xba, 0x23, 0xc4, 0x7b, 0xf3, 0x33, 0x57, 0xae,
	0x20, 0x25, 0x7e, 0x08, 0x1d, 0xc1, 0x81, 0xd9, 0x6f, 0xf4, 0x75, 0xeb, 0xa6, 0x6b, 0x5e, 0xeb,
	0xcd, 0xf6, 0x45, 0x5b, 0x6f, 0x15, 0xff, 0x42, 0xfb, 0x90, 0x6e, 0xb5, 0xcd, 0xc6, 0x79, 0x47,
	0x6f, 0x15, 0x15, 0x94, 0x83, 0x8c, 0xa1, 0x37, 0x5a, 0x56, 0xaf, 0xdb, 0xf9, 0x52, 0x4c, 0xa0,
	0x3c, 0x80, 0x68, 0x3f, 0x19, 0xed, 0xbe, 0x5e, 0x4c, 0x56, 0xbe, 0xef, 0x40, 0xae, 0x69, 0xfb,
	0x7e, 0x9f, 0xda, 0x0e, 0x1e, 0xd8, 0xce, 0x18, 0xbd, 0x85, 0x8c, 0x63, 0xfb, 0xbe, 0xc5, 0x66,
	0xe1, 0x62, 0x04, 0x95, 0xd5, 0x11, 0x3c, 0x60, 0xcb, 0x6e, 0x16, 0x62, 0x23, 0xed, 0xcc, 0x2b,
	0x1e, 0x5d, 0x18, 0x8c, 0xf1, 0x6c, 0x7e, 0xee, 0x3d, 0xde, 0x5f, 0xe1, 0x19, 0x7a, 0x0d, 0xfb,
	0x84, 0x7a, 0xae, 0x17, 0xf0, 0x05, 0x70, 0xc6, 0xe2, 0xdc, 0xd9, 0x7a, 0x69, 0xd5, 0x5e, 0x6e,
	0x63, 0xad, 0x49, 0x86, 0xb8, 0x85, 0x47, 0x46, 0x56, 0xf2, 0x4d, 0x4e, 0x47, 0xb7, 0x70, 0x38,
	0x97, 0x7b, 0x43, 0x8b, 0x11, 0x2b, 0x62, 0xd4, 0x0b, 0x5c, 0x75, 0x47, 0xac, 0x8f, 0xb6, 0x3d,
	0x64, 0x4f, 0x88, 0xda, 0xc3, 0x3e, 0x31, 0x85, 0x42, 0x0f, 0x18, 0x9d, 0x19, 0x45, 0xf2, 0x08,
	0x46, 0x17, 0x50, 0x70, 0xa9, 0x1d, 0xde, 0x59, 0x6c, 0x21, 0x55, 0x53, 0x22, 0xe1, 0x7f, 0x1b,
	0x12, 0xf6, 0xc2, 0x0e, 0x71, 0xe5, 0x42, 0xe5, 0x85, 0x6a, 0x39, 0xc2, 0xff, 0x21, 0x27, 0x7d,
	0xa6, 0x98, 0x46, 0x1e, 0x09, 0xd4, 0xdd, 0xb2, 0x52, 0x4d, 0x1a, 0xfb, 0x02, 0xfc, 0x28, 0xb1,
	0x52, 0x13, 0x8e, 0x36, 0xe6, 0x42, 0x45, 0x48, 0xf2, 0xd1, 0x29, 0x42, 0xc3, 0x4b, 0xf4, 0x37,
	0xa4, 0xa6, 0xb6, 0x1f, 0x2f, 0xd6, 0x48, 0x36, 0x2f, 0x13, 0x2f, 0x94, 0x8a, 0x0e, 0xe9, 0xc5,
	0x17, 0x40, 0x05, 0xc8, 0x3e, 0x5c, 0x84, 0x43, 0x28, 0x5c, 0x1a, 0x8d, 0xeb, 0xf7, 0x96, 0xfe,
	0x59, 0x6f, 0xde, 0xf4, 0xdb, 0xbd, 0x6e, 0x51, 0xe1, 0xa0, 0xde, 0xb8, 0xd4, 0x8d, 0x15, 0x30,
	0x51, 0xff, 0xa9, 0x40, 0x4e, 0xac, 0x76, 0xc7, 0x8b, 0x18, 0x0e, 0x30, 0x45, 0xaf, 0x00, 0x4c,
	0x1c, 0x0c, 0x05, 0x18, 0xa1, 0x83, 0xb5, 0x3b, 0x50, 0x3a, 0xde, 0x7c, 0x2d, 0xaa, 0xca, 0x33,
	0x05, 0x35, 0x21, 0xcf, 0xc5, 0xbf, 0x07, 0x12, 0xa1, 0x93, 0xad, 0x1f, 0x67, 0x9b, 0x11, 0xfa,
	0x00, 0x05, 0x6e, 0x62, 0x92, 0x98, 0x3a, 0xf8, 0xc2, 0xf3, 0x71, 0x84, 0x4e, 0x57, 0xa9, 0xe2,
	0xfe, 0xb9, 0x78, 0x95, 0xb0, 0xcd, 0xeb, 0xfc, 0xdd, 0xd7, 0x37, 0xae, 0xc7, 0xee, 0xe2, 0x41,
	0xcd, 0x21, 0x13, 0x6d, 0xe5, 0xe1, 0xda, 0x5c, 0xba, 0x44, 0xbe, 0x68, 0xcb, 0x67, 0x78, 0xb0,
	0x2b, 0x9e, 0xb4, 0xe7, 0xbf, 0x02, 0x00, 0x00, 0xff, 0xff, 0x32, 0xd0, 0xaf, 0x0a, 0xa6, 0x05,
	0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// EventListenerClient is the client API for EventListener service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type EventListenerClient interface {
	// Client(s) can use this RPC method to send the EventListener Event protos.
	// The Event protos can hold information such as:
	//   1) intermediate tensors from a debugged graph being executed, which can
	//      be sent from DebugIdentity ops configured with grpc URLs.
	//   2) GraphDefs of partition graphs, which can be sent from special debug
	//      ops that get executed immediately after the beginning of the graph
	//      execution.
	SendEvents(ctx context.Context, opts ...grpc.CallOption) (EventListener_SendEventsClient, error)
	// Send the tracebacks of a TensorFlow execution call.
	SendTracebacks(ctx context.Context, in *CallTraceback, opts ...grpc.CallOption) (*EventReply, error)
	// Send a collection of source code files being debugged.
	SendSourceFiles(ctx context.Context, in *protobuf.DebuggedSourceFiles, opts ...grpc.CallOption) (*EventReply, error)
}

type eventListenerClient struct {
	cc *grpc.ClientConn
}

func NewEventListenerClient(cc *grpc.ClientConn) EventListenerClient {
	return &eventListenerClient{cc}
}

func (c *eventListenerClient) SendEvents(ctx context.Context, opts ...grpc.CallOption) (EventListener_SendEventsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_EventListener_serviceDesc.Streams[0], "/tensorflow.EventListener/SendEvents", opts...)
	if err != nil {
		return nil, err
	}
	x := &eventListenerSendEventsClient{stream}
	return x, nil
}

type EventListener_SendEventsClient interface {
	Send(*util.Event) error
	Recv() (*EventReply, error)
	grpc.ClientStream
}

type eventListenerSendEventsClient struct {
	grpc.ClientStream
}

func (x *eventListenerSendEventsClient) Send(m *util.Event) error {
	return x.ClientStream.SendMsg(m)
}

func (x *eventListenerSendEventsClient) Recv() (*EventReply, error) {
	m := new(EventReply)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *eventListenerClient) SendTracebacks(ctx context.Context, in *CallTraceback, opts ...grpc.CallOption) (*EventReply, error) {
	out := new(EventReply)
	err := c.cc.Invoke(ctx, "/tensorflow.EventListener/SendTracebacks", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eventListenerClient) SendSourceFiles(ctx context.Context, in *protobuf.DebuggedSourceFiles, opts ...grpc.CallOption) (*EventReply, error) {
	out := new(EventReply)
	err := c.cc.Invoke(ctx, "/tensorflow.EventListener/SendSourceFiles", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// EventListenerServer is the server API for EventListener service.
type EventListenerServer interface {
	// Client(s) can use this RPC method to send the EventListener Event protos.
	// The Event protos can hold information such as:
	//   1) intermediate tensors from a debugged graph being executed, which can
	//      be sent from DebugIdentity ops configured with grpc URLs.
	//   2) GraphDefs of partition graphs, which can be sent from special debug
	//      ops that get executed immediately after the beginning of the graph
	//      execution.
	SendEvents(EventListener_SendEventsServer) error
	// Send the tracebacks of a TensorFlow execution call.
	SendTracebacks(context.Context, *CallTraceback) (*EventReply, error)
	// Send a collection of source code files being debugged.
	SendSourceFiles(context.Context, *protobuf.DebuggedSourceFiles) (*EventReply, error)
}

// UnimplementedEventListenerServer can be embedded to have forward compatible implementations.
type UnimplementedEventListenerServer struct {
}

func (*UnimplementedEventListenerServer) SendEvents(srv EventListener_SendEventsServer) error {
	return status.Errorf(codes.Unimplemented, "method SendEvents not implemented")
}
func (*UnimplementedEventListenerServer) SendTracebacks(ctx context.Context, req *CallTraceback) (*EventReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendTracebacks not implemented")
}
func (*UnimplementedEventListenerServer) SendSourceFiles(ctx context.Context, req *protobuf.DebuggedSourceFiles) (*EventReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendSourceFiles not implemented")
}

func RegisterEventListenerServer(s *grpc.Server, srv EventListenerServer) {
	s.RegisterService(&_EventListener_serviceDesc, srv)
}

func _EventListener_SendEvents_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(EventListenerServer).SendEvents(&eventListenerSendEventsServer{stream})
}

type EventListener_SendEventsServer interface {
	Send(*EventReply) error
	Recv() (*util.Event, error)
	grpc.ServerStream
}

type eventListenerSendEventsServer struct {
	grpc.ServerStream
}

func (x *eventListenerSendEventsServer) Send(m *EventReply) error {
	return x.ServerStream.SendMsg(m)
}

func (x *eventListenerSendEventsServer) Recv() (*util.Event, error) {
	m := new(util.Event)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _EventListener_SendTracebacks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CallTraceback)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventListenerServer).SendTracebacks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tensorflow.EventListener/SendTracebacks",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventListenerServer).SendTracebacks(ctx, req.(*CallTraceback))
	}
	return interceptor(ctx, in, info, handler)
}

func _EventListener_SendSourceFiles_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(protobuf.DebuggedSourceFiles)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventListenerServer).SendSourceFiles(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tensorflow.EventListener/SendSourceFiles",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventListenerServer).SendSourceFiles(ctx, req.(*protobuf.DebuggedSourceFiles))
	}
	return interceptor(ctx, in, info, handler)
}

var _EventListener_serviceDesc = grpc.ServiceDesc{
	ServiceName: "tensorflow.EventListener",
	HandlerType: (*EventListenerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SendTracebacks",
			Handler:    _EventListener_SendTracebacks_Handler,
		},
		{
			MethodName: "SendSourceFiles",
			Handler:    _EventListener_SendSourceFiles_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SendEvents",
			Handler:       _EventListener_SendEvents_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "tensorflow/core/debug/debug_service.proto",
}
