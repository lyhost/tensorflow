// Code generated by protoc-gen-go. DO NOT EDIT.
// source: tensorflow/core/protobuf/tpu/tpu_embedding_configuration.proto

package protobuf

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// Mode. Should the embedding layer program be run for inference (just forward
// pass), training (both forward and backward pass) or just the backward_pass.
type TPUEmbeddingConfiguration_Mode int32

const (
	TPUEmbeddingConfiguration_UNSPECIFIED        TPUEmbeddingConfiguration_Mode = 0
	TPUEmbeddingConfiguration_INFERENCE          TPUEmbeddingConfiguration_Mode = 1
	TPUEmbeddingConfiguration_TRAINING           TPUEmbeddingConfiguration_Mode = 2
	TPUEmbeddingConfiguration_BACKWARD_PASS_ONLY TPUEmbeddingConfiguration_Mode = 3
)

var TPUEmbeddingConfiguration_Mode_name = map[int32]string{
	0: "UNSPECIFIED",
	1: "INFERENCE",
	2: "TRAINING",
	3: "BACKWARD_PASS_ONLY",
}

var TPUEmbeddingConfiguration_Mode_value = map[string]int32{
	"UNSPECIFIED":        0,
	"INFERENCE":          1,
	"TRAINING":           2,
	"BACKWARD_PASS_ONLY": 3,
}

func (x TPUEmbeddingConfiguration_Mode) String() string {
	return proto.EnumName(TPUEmbeddingConfiguration_Mode_name, int32(x))
}

func (TPUEmbeddingConfiguration_Mode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_300b8f469a86bd9c, []int{0, 0}
}

// Sharding strategy of the embedding tables among the hosts.
// If the sharding_strategy is "mod", each id is assigned to host
// "id % num_hosts". For instance, 13 ids are split across 5 hosts as:
// [[0, 5, 10], [1, 6, 11], [2, 7, 12], [3, 8], [4, 9]].
// If the sharding_strategy is "div", ids are assigned to hosts in a
// contiguous manner. In this case, 13 ids are split across 5 hosts as:
// [[0, 1, 2], [3, 4, 5], [6, 7, 8], [9, 10], [11, 12]].
// In both the strategies, if the id space does not evenly divide the number
// of hosts, each of the first "table_descriptor.vocabulary_size % num_hosts"
// hosts will be assigned one more id.
// This partitioning strategy exactly follows that in the embedding_lookup
// TensorFlow function at tensorflow/python/ops/embedding_ops.py.
type TPUEmbeddingConfiguration_ShardingStrategy int32

const (
	TPUEmbeddingConfiguration_DIV_DEFAULT TPUEmbeddingConfiguration_ShardingStrategy = 0
	TPUEmbeddingConfiguration_MOD         TPUEmbeddingConfiguration_ShardingStrategy = 1
)

var TPUEmbeddingConfiguration_ShardingStrategy_name = map[int32]string{
	0: "DIV_DEFAULT",
	1: "MOD",
}

var TPUEmbeddingConfiguration_ShardingStrategy_value = map[string]int32{
	"DIV_DEFAULT": 0,
	"MOD":         1,
}

func (x TPUEmbeddingConfiguration_ShardingStrategy) String() string {
	return proto.EnumName(TPUEmbeddingConfiguration_ShardingStrategy_name, int32(x))
}

func (TPUEmbeddingConfiguration_ShardingStrategy) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_300b8f469a86bd9c, []int{0, 1}
}

type TPUEmbeddingConfiguration struct {
	TableDescriptor []*TPUEmbeddingConfiguration_TableDescriptor `protobuf:"bytes,1,rep,name=table_descriptor,json=tableDescriptor,proto3" json:"table_descriptor,omitempty"`
	Mode            TPUEmbeddingConfiguration_Mode               `protobuf:"varint,2,opt,name=mode,proto3,enum=tensorflow.tpu.TPUEmbeddingConfiguration_Mode" json:"mode,omitempty"`
	// Number of samples in each batch of embedding layer activations sent to
	// the TensorCore.
	BatchSizePerTensorCore int32 `protobuf:"varint,3,opt,name=batch_size_per_tensor_core,json=batchSizePerTensorCore,proto3" json:"batch_size_per_tensor_core,omitempty"`
	// Number of TPU hosts used for inference/training.
	NumHosts int32 `protobuf:"varint,4,opt,name=num_hosts,json=numHosts,proto3" json:"num_hosts,omitempty"`
	// Number of TensorCore used for inference/training.
	NumTensorCores   int32                                      `protobuf:"varint,5,opt,name=num_tensor_cores,json=numTensorCores,proto3" json:"num_tensor_cores,omitempty"`
	ShardingStrategy TPUEmbeddingConfiguration_ShardingStrategy `protobuf:"varint,6,opt,name=sharding_strategy,json=shardingStrategy,proto3,enum=tensorflow.tpu.TPUEmbeddingConfiguration_ShardingStrategy" json:"sharding_strategy,omitempty"`
	// This parameter determines if the execution of the sparse core will be
	// pipelined with that of the TensorCore. This parameter only affects results
	// when mode=TRAINING. If mode=INFERENCE or BACKWARD_PASS_ONLY, this parameter
	// does not affect execution and hence, is a don't care value.
	//
	// false: The execution of the sparse core is not pipelined with that of the
	// TensorCore. The forward pass of every step on the sparse core is executed
	// only after the backward pass of the previous step is complete. And the
	// backward pass on the sparse core is executed only after the embedding
	// gradients have been computed on the TensorCore on every step. This ensures
	// that the activations on every step observe the gradient updates from the
	// previous step on both the sparse core and the TensorCore.
	//
	// true: The execution of the sparse core is pipelined with that of the
	// TensorCore. The forward pass of every step on the sparse core can be
	// executed after the forward pass of the previous step is complete without
	// waiting for the backward pass. This improves the utilization of the sparse
	// core allowing it to process step N+1 while the embedding gradients for step
	// N are computed on the TensorCore. The backward pass of every step on the
	// sparse core is executed directly after the forward pass for the next step
	// is complete. The drawback is that embedding activations for step N+1 do not
	// observe the embedding gradient updates from step N. This could affect model
	// quality if step N and N+1 involve the same set of embedding IDs. However,
	// since the embedding updates are sparse, this is generally not considered a
	// problem.
	PipelineExecutionWithTensorCore bool `protobuf:"varint,7,opt,name=pipeline_execution_with_tensor_core,json=pipelineExecutionWithTensorCore,proto3" json:"pipeline_execution_with_tensor_core,omitempty"`
	// Extended output layout information; if not provided, a compatibility mode
	// will use defaults that match the old layout. Providing a value for this
	// field is EXPERIMENTAL and most ways of filling it will probably break. Do
	// not set it unless you know what you are doing.
	OutputLayout         *TPUEmbeddingOutputLayout `protobuf:"bytes,8,opt,name=output_layout,json=outputLayout,proto3" json:"output_layout,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                  `json:"-"`
	XXX_unrecognized     []byte                    `json:"-"`
	XXX_sizecache        int32                     `json:"-"`
}

func (m *TPUEmbeddingConfiguration) Reset()         { *m = TPUEmbeddingConfiguration{} }
func (m *TPUEmbeddingConfiguration) String() string { return proto.CompactTextString(m) }
func (*TPUEmbeddingConfiguration) ProtoMessage()    {}
func (*TPUEmbeddingConfiguration) Descriptor() ([]byte, []int) {
	return fileDescriptor_300b8f469a86bd9c, []int{0}
}

func (m *TPUEmbeddingConfiguration) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TPUEmbeddingConfiguration.Unmarshal(m, b)
}
func (m *TPUEmbeddingConfiguration) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TPUEmbeddingConfiguration.Marshal(b, m, deterministic)
}
func (m *TPUEmbeddingConfiguration) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TPUEmbeddingConfiguration.Merge(m, src)
}
func (m *TPUEmbeddingConfiguration) XXX_Size() int {
	return xxx_messageInfo_TPUEmbeddingConfiguration.Size(m)
}
func (m *TPUEmbeddingConfiguration) XXX_DiscardUnknown() {
	xxx_messageInfo_TPUEmbeddingConfiguration.DiscardUnknown(m)
}

var xxx_messageInfo_TPUEmbeddingConfiguration proto.InternalMessageInfo

func (m *TPUEmbeddingConfiguration) GetTableDescriptor() []*TPUEmbeddingConfiguration_TableDescriptor {
	if m != nil {
		return m.TableDescriptor
	}
	return nil
}

func (m *TPUEmbeddingConfiguration) GetMode() TPUEmbeddingConfiguration_Mode {
	if m != nil {
		return m.Mode
	}
	return TPUEmbeddingConfiguration_UNSPECIFIED
}

func (m *TPUEmbeddingConfiguration) GetBatchSizePerTensorCore() int32 {
	if m != nil {
		return m.BatchSizePerTensorCore
	}
	return 0
}

func (m *TPUEmbeddingConfiguration) GetNumHosts() int32 {
	if m != nil {
		return m.NumHosts
	}
	return 0
}

func (m *TPUEmbeddingConfiguration) GetNumTensorCores() int32 {
	if m != nil {
		return m.NumTensorCores
	}
	return 0
}

func (m *TPUEmbeddingConfiguration) GetShardingStrategy() TPUEmbeddingConfiguration_ShardingStrategy {
	if m != nil {
		return m.ShardingStrategy
	}
	return TPUEmbeddingConfiguration_DIV_DEFAULT
}

func (m *TPUEmbeddingConfiguration) GetPipelineExecutionWithTensorCore() bool {
	if m != nil {
		return m.PipelineExecutionWithTensorCore
	}
	return false
}

func (m *TPUEmbeddingConfiguration) GetOutputLayout() *TPUEmbeddingOutputLayout {
	if m != nil {
		return m.OutputLayout
	}
	return nil
}

// Description of the various embedding tables.
type TPUEmbeddingConfiguration_TableDescriptor struct {
	// Name of the table.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Size of the vocabulary (i.e., number of rows) in the table.
	VocabularySize int32 `protobuf:"varint,2,opt,name=vocabulary_size,json=vocabularySize,proto3" json:"vocabulary_size,omitempty"`
	// The embedding dimension (i.e., the width of the embedding table).
	Dimension int32 `protobuf:"varint,3,opt,name=dimension,proto3" json:"dimension,omitempty"`
	// Number of features mapped to this table.
	NumFeatures int32 `protobuf:"varint,4,opt,name=num_features,json=numFeatures,proto3" json:"num_features,omitempty"`
	// Details of the learning algorithm used to update the embedding
	// parameters.
	OptimizationParameters *OptimizationParameters `protobuf:"bytes,5,opt,name=optimization_parameters,json=optimizationParameters,proto3" json:"optimization_parameters,omitempty"`
	XXX_NoUnkeyedLiteral   struct{}                `json:"-"`
	XXX_unrecognized       []byte                  `json:"-"`
	XXX_sizecache          int32                   `json:"-"`
}

func (m *TPUEmbeddingConfiguration_TableDescriptor) Reset() {
	*m = TPUEmbeddingConfiguration_TableDescriptor{}
}
func (m *TPUEmbeddingConfiguration_TableDescriptor) String() string { return proto.CompactTextString(m) }
func (*TPUEmbeddingConfiguration_TableDescriptor) ProtoMessage()    {}
func (*TPUEmbeddingConfiguration_TableDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_300b8f469a86bd9c, []int{0, 0}
}

func (m *TPUEmbeddingConfiguration_TableDescriptor) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TPUEmbeddingConfiguration_TableDescriptor.Unmarshal(m, b)
}
func (m *TPUEmbeddingConfiguration_TableDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TPUEmbeddingConfiguration_TableDescriptor.Marshal(b, m, deterministic)
}
func (m *TPUEmbeddingConfiguration_TableDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TPUEmbeddingConfiguration_TableDescriptor.Merge(m, src)
}
func (m *TPUEmbeddingConfiguration_TableDescriptor) XXX_Size() int {
	return xxx_messageInfo_TPUEmbeddingConfiguration_TableDescriptor.Size(m)
}
func (m *TPUEmbeddingConfiguration_TableDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_TPUEmbeddingConfiguration_TableDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_TPUEmbeddingConfiguration_TableDescriptor proto.InternalMessageInfo

func (m *TPUEmbeddingConfiguration_TableDescriptor) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *TPUEmbeddingConfiguration_TableDescriptor) GetVocabularySize() int32 {
	if m != nil {
		return m.VocabularySize
	}
	return 0
}

func (m *TPUEmbeddingConfiguration_TableDescriptor) GetDimension() int32 {
	if m != nil {
		return m.Dimension
	}
	return 0
}

func (m *TPUEmbeddingConfiguration_TableDescriptor) GetNumFeatures() int32 {
	if m != nil {
		return m.NumFeatures
	}
	return 0
}

func (m *TPUEmbeddingConfiguration_TableDescriptor) GetOptimizationParameters() *OptimizationParameters {
	if m != nil {
		return m.OptimizationParameters
	}
	return nil
}

func init() {
	proto.RegisterEnum("tensorflow.tpu.TPUEmbeddingConfiguration_Mode", TPUEmbeddingConfiguration_Mode_name, TPUEmbeddingConfiguration_Mode_value)
	proto.RegisterEnum("tensorflow.tpu.TPUEmbeddingConfiguration_ShardingStrategy", TPUEmbeddingConfiguration_ShardingStrategy_name, TPUEmbeddingConfiguration_ShardingStrategy_value)
	proto.RegisterType((*TPUEmbeddingConfiguration)(nil), "tensorflow.tpu.TPUEmbeddingConfiguration")
	proto.RegisterType((*TPUEmbeddingConfiguration_TableDescriptor)(nil), "tensorflow.tpu.TPUEmbeddingConfiguration.TableDescriptor")
}

func init() {
	proto.RegisterFile("tensorflow/core/protobuf/tpu/tpu_embedding_configuration.proto", fileDescriptor_300b8f469a86bd9c)
}

var fileDescriptor_300b8f469a86bd9c = []byte{
	// 618 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x94, 0xdd, 0x6e, 0xda, 0x30,
	0x14, 0xc7, 0x9b, 0x42, 0x5b, 0x30, 0x2d, 0x64, 0xbe, 0xe8, 0x32, 0x36, 0x69, 0xac, 0x93, 0xb6,
	0x5c, 0x4c, 0x41, 0x62, 0x57, 0xab, 0xa6, 0x4a, 0x14, 0xc2, 0x86, 0x46, 0x01, 0x05, 0xba, 0x6a,
	0xbb, 0xb1, 0xf2, 0x61, 0xc0, 0x12, 0xb1, 0x23, 0x7f, 0xac, 0x6b, 0xdf, 0x6d, 0xef, 0xb4, 0x47,
	0x98, 0x62, 0xa0, 0x04, 0xd4, 0x56, 0xdd, 0x45, 0x24, 0xfb, 0xf8, 0x7f, 0x7e, 0x3a, 0xc7, 0xff,
	0x13, 0x83, 0x33, 0x89, 0xa9, 0x60, 0x7c, 0x32, 0x67, 0xd7, 0xf5, 0x90, 0x71, 0x5c, 0x4f, 0x38,
	0x93, 0x2c, 0x50, 0x93, 0xba, 0x4c, 0x54, 0xfa, 0x21, 0x1c, 0x07, 0x38, 0x8a, 0x08, 0x9d, 0xa2,
	0x90, 0xd1, 0x09, 0x99, 0x2a, 0xee, 0x4b, 0xc2, 0xa8, 0xa3, 0x85, 0xb0, 0xbc, 0xce, 0x77, 0x64,
	0xa2, 0xaa, 0xa7, 0x8f, 0xf2, 0x58, 0x22, 0x49, 0x4c, 0x6e, 0x35, 0x00, 0x25, 0x3e, 0xf7, 0x63,
	0x2c, 0x31, 0x17, 0x0b, 0x56, 0xf5, 0x7f, 0x6a, 0x61, 0x4a, 0x26, 0x4a, 0xa2, 0xb9, 0x7f, 0xc3,
	0x94, 0x5c, 0xe4, 0x9f, 0xfc, 0x39, 0x00, 0x2f, 0xc6, 0xc3, 0x4b, 0x77, 0x25, 0x6a, 0x65, 0xeb,
	0x85, 0x11, 0x30, 0xa5, 0x1f, 0xcc, 0x31, 0x8a, 0xb0, 0x08, 0x39, 0x49, 0x24, 0xe3, 0x96, 0x51,
	0xcb, 0xd9, 0xa5, 0xc6, 0x27, 0x67, 0xb3, 0x09, 0xe7, 0x41, 0x88, 0x33, 0x4e, 0x09, 0xed, 0x3b,
	0x80, 0x57, 0x91, 0x9b, 0x01, 0x78, 0x0e, 0xf2, 0x31, 0x8b, 0xb0, 0xb5, 0x5b, 0x33, 0xec, 0x72,
	0xc3, 0x79, 0x3a, 0xf9, 0x82, 0x45, 0xd8, 0xd3, 0xb9, 0xf0, 0x14, 0x54, 0x03, 0x5f, 0x86, 0x33,
	0x24, 0xc8, 0x2d, 0x46, 0x09, 0xe6, 0x68, 0x41, 0x41, 0xe9, 0xa5, 0x58, 0xb9, 0x9a, 0x61, 0xef,
	0x79, 0xc7, 0x5a, 0x31, 0x22, 0xb7, 0x78, 0x88, 0xf9, 0x58, 0x1f, 0xb7, 0x18, 0xc7, 0xf0, 0x25,
	0x28, 0x52, 0x15, 0xa3, 0x19, 0x13, 0x52, 0x58, 0x79, 0x2d, 0x2d, 0x50, 0x15, 0x7f, 0x4d, 0xf7,
	0xd0, 0x06, 0x66, 0x7a, 0x98, 0xa1, 0x09, 0x6b, 0x4f, 0x6b, 0xca, 0x54, 0xc5, 0x6b, 0x8a, 0x80,
	0x53, 0xf0, 0x4c, 0xcc, 0x7c, 0xae, 0xaf, 0x5a, 0x48, 0xee, 0x4b, 0x3c, 0xbd, 0xb1, 0xf6, 0x75,
	0x4f, 0xa7, 0x4f, 0xef, 0x69, 0xb4, 0x44, 0x8c, 0x96, 0x04, 0xcf, 0x14, 0x5b, 0x11, 0xd8, 0x03,
	0x6f, 0x13, 0x92, 0xe0, 0x39, 0xa1, 0x18, 0xe1, 0xdf, 0x38, 0x54, 0x7a, 0x34, 0xae, 0x89, 0x9c,
	0x6d, 0x34, 0x7d, 0x50, 0x33, 0xec, 0x82, 0xf7, 0x7a, 0x25, 0x75, 0x57, 0xca, 0x2b, 0x22, 0x67,
	0x99, 0xee, 0x2f, 0xc0, 0xd1, 0xc6, 0x60, 0x58, 0x85, 0x9a, 0x61, 0x97, 0x1a, 0xf6, 0x63, 0x25,
	0x0f, 0x74, 0x42, 0x4f, 0xeb, 0xbd, 0x43, 0x96, 0xd9, 0x55, 0xff, 0x1a, 0xa0, 0xb2, 0xe5, 0x38,
	0x84, 0x20, 0x4f, 0xfd, 0x18, 0x5b, 0x46, 0xcd, 0xb0, 0x8b, 0x9e, 0x5e, 0xc3, 0xf7, 0xa0, 0xf2,
	0x8b, 0x85, 0x7e, 0xa0, 0xe6, 0x3e, 0xbf, 0xd1, 0xae, 0x69, 0xff, 0xf7, 0xbc, 0xf2, 0x3a, 0x9c,
	0x5a, 0x05, 0x5f, 0x81, 0x62, 0x44, 0x62, 0x4c, 0x05, 0x61, 0x74, 0x69, 0xe4, 0x3a, 0x00, 0xdf,
	0x80, 0xc3, 0xd4, 0x9e, 0x09, 0xf6, 0xa5, 0x4a, 0xad, 0x59, 0xd8, 0x57, 0xa2, 0x2a, 0xee, 0x2c,
	0x43, 0x10, 0x81, 0xe7, 0x0f, 0xfc, 0x43, 0xda, 0xc8, 0x52, 0xe3, 0xdd, 0x76, 0xab, 0x83, 0x8c,
	0x7c, 0x78, 0xa7, 0xf6, 0x8e, 0xd9, 0xbd, 0xf1, 0x93, 0x1e, 0xc8, 0xa7, 0x93, 0x08, 0x2b, 0xa0,
	0x74, 0xd9, 0x1f, 0x0d, 0xdd, 0x56, 0xb7, 0xd3, 0x75, 0xdb, 0xe6, 0x0e, 0x3c, 0x02, 0xc5, 0x6e,
	0xbf, 0xe3, 0x7a, 0x6e, 0xbf, 0xe5, 0x9a, 0x06, 0x3c, 0x04, 0x85, 0xb1, 0xd7, 0xec, 0xf6, 0xbb,
	0xfd, 0x2f, 0xe6, 0x2e, 0x3c, 0x06, 0xf0, 0xbc, 0xd9, 0xfa, 0x76, 0xd5, 0xf4, 0xda, 0x68, 0xd8,
	0x1c, 0x8d, 0xd0, 0xa0, 0xdf, 0xfb, 0x61, 0xe6, 0x4e, 0x3e, 0x00, 0x73, 0x7b, 0x06, 0x52, 0x72,
	0xbb, 0xfb, 0x1d, 0xb5, 0xdd, 0x4e, 0xf3, 0xb2, 0x37, 0x36, 0x77, 0xe0, 0x01, 0xc8, 0x5d, 0x0c,
	0xda, 0xa6, 0x71, 0x7e, 0xf6, 0xf3, 0xf3, 0x94, 0xc8, 0x99, 0x0a, 0x9c, 0x90, 0xc5, 0xf5, 0xcc,
	0x63, 0x70, 0xff, 0x72, 0xca, 0x36, 0x5f, 0x89, 0x60, 0x5f, 0xaf, 0x3e, 0xfe, 0x0b, 0x00, 0x00,
	0xff, 0xff, 0x5e, 0x77, 0x25, 0x68, 0xd4, 0x04, 0x00, 0x00,
}
